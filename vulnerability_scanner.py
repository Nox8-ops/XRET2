import argparse
import asyncio
import json
import os
import requests
import time
import nmap
import joblib
import pandas as pd
from tqdm import tqdm
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from keras.models import load_model
import numpy as np
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from faker import Faker
from rich.console import Console
from rich.table import Table
from selenium import webdriver
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service as ChromeService
from web3 import Web3

class ZAPScanner:
    def open_url(self, url):
        # Implement ZAPScanner methods
        pass
    def start_scan(self, url):
        pass
    def get_results(self):
        return []

class BurpScanner:
    def __init__(self, url, api_key):
        self.url = url
        self.api_key = api_key
    def open_url(self, url):
        pass
    def start_scan(self, url):
        pass
    def get_results(self):
        return []

class PyppeteerScanner:
    async def open_url(self, url):
        pass
    async def close_browser(self):
        pass

class XRET:
    def __init__(self, target, dynamic=False, max_threads=4):
        self.target = target
        self.vulnerabilities = []
        self.report = {}
        self.zap_scanner = ZAPScanner()
        self.burp_scanner = BurpScanner(os.getenv("BURP_URL", "http://localhost:1337/v1"), os.getenv("BURP_API_KEY", "your_api_key_here"))
        self.pyppeteer_scanner = PyppeteerScanner()
        self.load_recommendations()
        self.model = load_model('model/vulnerability_model.h5')
        self.dynamic = dynamic
        self.faker = Faker()
        self.console = Console()
        self.max_threads = max_threads
        self.w3 = None  # Initialize Web3 instance
        self.create_sessions()

    def create_session(self):
        session = requests.Session()
        retry_strategy = Retry(
            total=5,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            method_whitelist=["HEAD", "GET", "OPTIONS", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("https://", adapter)
        session.mount("http://", adapter)
        return session

    def create_sessions(self):
        self.sessions = []
        for _ in range(self.max_threads):
            self.sessions.append(self.create_session())

    def load_recommendations(self):
        with open('recommendations.json', 'r') as file:
            self.recommendations = json.load(file)

    def initialize_blockchain(self):
        # Connect to local Ganache blockchain
        ganache_url = "http://127.0.0.1:7545"
        self.w3 = Web3(Web3.HTTPProvider(ganache_url))
        if self.w3.isConnected():
            print("Connected to Blockchain")
        else:
            print("Failed to connect to Blockchain")

        # Example: Register node on blockchain
        self.register_node_on_blockchain()

    def register_node_on_blockchain(self):
        account = self.w3.eth.accounts[0]
        tx_hash = self.w3.eth.send_transaction({
            'from': account,
            'to': account,
            'value': self.w3.toWei(1, 'ether'),
            'data': self.w3.toBytes(text=f"Node registered for {self.target}")
        })
        receipt = self.w3.eth.waitForTransactionReceipt(tx_hash)
        print(f"Node registered with transaction hash: {receipt.transactionHash.hex()}")

    def scan_vulnerabilities(self):
        self.initialize_blockchain()
        with ProcessPoolExecutor(max_workers=self.max_threads) as executor:
            futures = [
                executor.submit(self.scan_web_vulnerabilities, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_network_vulnerabilities, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_ssl_tls_vulnerabilities, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_with_burp, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_xss, self.sessions[i % len(self.sessions)]) if self.dynamic else None,
                executor.submit(self.scan_csrf, self.sessions[i % len(self.sessions)]) if self.dynamic else None,
                executor.submit(self.scan_command_injection, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_insecure_deserialization, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_csrf_token_missing, self.sessions[i % len(self.sessions)]),
                executor.submit(self.generate_evasive_payloads),
                executor.submit(self.bypass_403_401, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_databases, self.sessions[i % len(self.sessions)]),
                executor.submit(self.scan_network_services),
                executor.submit(self.test_idor, self.sessions[i % len(self.sessions)]),
                executor.submit(self.test_parameter_pollution, self.sessions[i % len(self.sessions)]),
                executor.submit(self.test_lfi, self.sessions[i % len(self.sessions)]),
                executor.submit(self.test_xxe, self.sessions[i % len(self.sessions)]),
                executor.submit(self.test_template_injection, self.sessions[i % len(self.sessions)]),
                executor.submit(self.test_ssrf, self.sessions[i % len(self.sessions)]),
                executor.submit(self.bypass_admin_panel, self.sessions[i % len(self.sessions)]),
                executor.submit(self.bypass_403_401, self.sessions[i % len(self.sessions)]),
            ]
            for future in futures:
                if future:
                    result = future.result()

    def scan_web_vulnerabilities(self, session):
        print(f"\nStarting web vulnerability scan on {self.target}")
        self.zap_scanner.open_url(self.target)
        self.zap_scanner.start_scan(self.target)
        alerts = self.zap_scanner.get_results()
        self.vulnerabilities.extend(alerts)
        print(f"Web vulnerability scan completed for {self.target}")

    def scan_network_vulnerabilities(self, session):
        print(f"\nStarting network vulnerability scan on {self.target}")
        nm = nmap.PortScanner()
        nm.scan(self.target, '1-65535', '-sV')
        for host in nm.all_hosts():
            for proto in nm[host].all_protocols():
                lport = nm[host][proto].keys()
                for port in lport:
                    service = nm[host][proto][port]['name']
                    state = nm[host][proto][port]['state']
                    if state == 'open':
                        self.vulnerabilities.append({
                            "id": f"network-{port}",
                            "description": f"Open port {port} with service {service} on {proto} protocol"
                        })
        print(f"Network vulnerability scan completed for {self.target}")

    def scan_ssl_tls_vulnerabilities(self, session):
        print(f"\nStarting SSL/TLS vulnerability scan on {self.target}")
        response = session.get(f"https://api.ssllabs.com/api/v3/analyze?host={self.target}", timeout=10)
        data = response.json()
        self.vulnerabilities.append(data)
        print(f"SSL/TLS vulnerability scan completed for {self.target}")

    def scan_with_burp(self, session):
        print(f"\nStarting Burp Suite scan on {self.target}")
        self.burp_scanner.open_url(self.target)
        self.burp_scanner.start_scan(self.target)
        results = self.burp_scanner.get_results()
        self.vulnerabilities.extend(results)
        print(f"Burp Suite scan completed for {self.target}")

    async def scan_xss(self, session):
        print(f"\nStarting XSS scan on {self.target}")
        await self.pyppeteer_scanner.open_url(self.target)
        inputs = await self.pyppeteer_scanner.page.querySelectorAll("input")
        for input_element in inputs:
            try:
                await input_element.type("<script>alert('XSS')</script>")
                await input_element.press("Enter")
                await self.pyppeteer_scanner.page.waitForFunction("() => document.querySelector('body').innerText.includes('XSS')")
                self.vulnerabilities.append({
                    "id": f"xss-{await self.pyppeteer_scanner.page.evaluate('(element) => element.name', input_element)}",
                    "description": "XSS vulnerability detected",
                    "predicted_type": "XSS"
                })
            except Exception as e:
                pass

        await self.pyppeteer_scanner.close_browser()
        print(f"XSS scan completed for {self.target}")

    async def scan_csrf(self, session):
        print(f"\nStarting CSRF scan on {self.target}")
        fake_email = self.faker.email()
        fake_password = self.faker.password()

        await self.pyppeteer_scanner.open_url(self.target)
        try:
            await self.pyppeteer_scanner.page.type('input[name="email"]', fake_email)
            await self.pyppeteer_scanner.page.type('input[name="password"]', fake_password)
            await self.pyppeteer_scanner.page.click('input[type="submit"]')

                       csrf_protected_form = await self.pyppeteer_scanner.page.querySelector("form")
            if csrf_protected_form:
                self.vulnerabilities.append({
                    "id": "csrf-1",
                    "description": "Potential CSRF vulnerability detected",
                    "predicted_type": "CSRF"
                })
        except Exception as e:
            pass

        await self.pyppeteer_scanner.close_browser()
        print(f"CSRF scan completed for {self.target}")

    def scan_command_injection(self, session):
        print(f"\nStarting Command Injection scan on {self.target}")
        payloads = [";ls;", "&&whoami", "|id"]
        for payload in payloads:
            response = session.post(self.target, data={"input": payload})
            if "root" in response.text or "uid=" in response.text:
                self.vulnerabilities.append({
                    "id": "cmd-injection-1",
                    "description": f"Command Injection vulnerability detected with payload: {payload}",
                    "predicted_type": "Command Injection"
                })
        print(f"Command Injection scan completed for {self.target}")

    def scan_insecure_deserialization(self, session):
        print(f"\nStarting Insecure Deserialization scan on {self.target}")
        payloads = ["O:8:\"FooClass\":0:{}", "a:2:{i:0;s:4:\"test\";i:1;s:4:\"test\";}"]
        for payload in payloads:
            response = session.post(self.target, data={"input": payload})
            if "Deserialization" in response.text:
                self.vulnerabilities.append({
                    "id": "insecure-deserialization-1",
                    "description": f"Insecure Deserialization vulnerability detected with payload: {payload}",
                    "predicted_type": "Insecure Deserialization"
                })
        print(f"Insecure Deserialization scan completed for {self.target}")

    def scan_csrf_token_missing(self, session):
        print(f"\nStarting CSRF Token Missing scan on {self.target}")
        response = session.post(self.target, data={"input": "test"})
        if "CSRF token missing" in response.text:
            self.vulnerabilities.append({
                "id": "csrf-token-missing-1",
                "description": "CSRF Token Missing vulnerability detected",
                "predicted_type": "CSRF Token Missing"
            })
        print(f"CSRF Token Missing scan completed for {self.target}")

    def generate_evasive_payloads(self, session):
        print(f"\nGenerating evasive payloads for {self.target}")
        payloads = ["<svg/onload=alert(1)>", "<img src=x onerror=alert(1)>"]
        for payload in payloads:
            response = session.post(self.target, data={"input": payload})
            if "alert" in response.text:
                self.vulnerabilities.append({
                    "id": "evasive-payload-1",
                    "description": f"Evasive payload vulnerability detected with payload: {payload}",
                    "predicted_type": "Evasive Payload"
                })
        print(f"Evasive payload generation completed for {self.target}")

    def bypass_403_401(self, session):
        print(f"\nStarting 403/401 Bypass scan on {self.target}")
        headers = {'X-Original-URL': '/admin'}
        response = session.get(self.target, headers=headers)
        if response.status_code == 200:
            self.vulnerabilities.append({
                "id": "bypass-403-401-1",
                "description": "403/401 Bypass vulnerability detected",
                "predicted_type": "Bypass"
            })
        print(f"403/401 Bypass scan completed for {self.target}")

    def scan_databases(self, session):
        print(f"\nStarting Database scan on {self.target}")
        payloads = ["1' OR '1'='1", "' UNION SELECT null, null, null--"]
        for payload in payloads:
            response = session.post(self.target, data={"input": payload})
            if "database error" in response.text:
                self.vulnerabilities.append({
                    "id": "database-1",
                    "description": f"Database vulnerability detected with payload: {payload}",
                    "predicted_type": "SQL Injection"
                })
        print(f"Database scan completed for {self.target}")

    def scan_network_services(self, session):
        print(f"\nStarting Network Services scan on {self.target}")
        services = ["http", "https", "ftp", "ssh"]
        for service in services:
            response = session.get(f"{service}://{self.target}")
            if response.status_code == 200:
                self.vulnerabilities.append({
                    "id": f"network-service-{service}",
                    "description": f"Network service {service} is accessible",
                    "predicted_type": "Network Service"
                })
        print(f"Network Services scan completed for {self.target}")

    def analyze_vulnerabilities(self):
        print("\nAnalyzing vulnerabilities using machine learning model...")
        features = self.extract_features(self.vulnerabilities)
        predictions = self.model.predict(features)
        for i, vuln in enumerate(self.vulnerabilities):
            vuln['predicted_type'] = predictions[i]

    def extract_features(self, vulnerabilities):
        return pd.DataFrame(vulnerabilities)

    def generate_report(self):
        print("\nGenerating report...")
        self.analyze_vulnerabilities()
        self.report['target'] = self.target
        self.report['vulnerabilities'] = self.vulnerabilities
        self.add_screenshots()
        self.add_recommendations()
        self.save_report()
        self.display_report()
        print("Report generated successfully")
        print(f"Report saved to {self.target}_report.json")

    def add_screenshots(self):
        options = webdriver.ChromeOptions()
        options.add_argument('--headless')
        driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()), options=options)
        driver.get(self.target)
        screenshot_path = f"{self.target}_screenshot.png"
        driver.save_screenshot(screenshot_path)
        driver.quit()
        self.report['screenshot'] = screenshot_path

    def add_recommendations(self):
        for vuln in self.vulnerabilities:
            vuln['recommendations'] = self.get_recommendation(vuln)

    def get_recommendation(self, vuln):
        vuln_type = vuln.get('predicted_type', 'Unknown')
        rec = self.recommendations.get(vuln_type, {})
        return {
            "description": rec.get("description", "No description available."),
            "exploitation": rec.get("exploitation", []),
            "bypass_waf": rec.get("bypass_waf", []),
            "recommendations": rec.get("recommendations", "No recommendations available.")
        }

    def save_report(self):
        report_path = f"{self.target}_report.json"
        with open(report_path, 'w') as report_file:
            json.dump(self.report, report_file, indent=4)

    def display_report(self):
        console = Console()
        table = Table(title="Vulnerability Report")
        table.add_column("ID", style="cyan", no_wrap=True)
        table.add_column("Description", style="magenta")
        table.add_column("Type", style="green")
        table.add_column("Exploitation", style="red")
        table.add_column("Recommendations", style="yellow")

        for vuln in self.vulnerabilities:
            recommendations = vuln.get("recommendations", {})
            rec_text = recommendations.get("description", "No description available.")
            exploitation = "\n".join(recommendations.get("exploitation", ["No exploitation available."]))
            bypass_waf = "\n".join(recommendations.get("bypass_waf", ["No bypass WAF techniques available."]))
            recs = recommendations.get("recommendations", "No recommendations available.")
            table.add_row(vuln['id'], vuln['description'], vuln.get('predicted_type', 'Unknown'), exploitation, f"{rec_text}\n{bypass_waf}\n{recs}")

        console.print(table)

    def integrate_with_security_systems(self):
        print("\nIntegrating with security systems...")
        # Example integration with Splunk
        splunk_url = "http://localhost:8088/services/collector"
        splunk_token = "your-splunk-token"
        headers = {
            "Authorization": f"Splunk {splunk_token}",
            "Content-Type": "application/json"
        }
        for vuln in self.vulnerabilities:
            data = {
                "event": vuln,
                "sourcetype": "_json"
            }
            response = self.sessions[0].post(splunk_url, headers=headers, data=json.dumps(data))
            if response.status_code != 200:
                print(f"Failed to send data to Splunk: {response.text}")

        # Example integration with ELK Stack (Elasticsearch)
        elk_url = "http://localhost:9200/vulnerabilities/_doc"
        for vuln in self.vulnerabilities:
            response = self.sessions[0].post(elk_url, headers={"Content-Type": "application/json"}, data=json.dumps(vuln))
            if response.status_code != 201:
                print(f"Failed to send data to ELK Stack: {response.text}")

def display_banner():
    banner = """
  _  __    _____  __________ 
 | |/ /   /  _/ |/ /_  __/ / 
 |   /    / //    / / / / /  
/   |   _/ // /|  / / / / /___
/_/|_|  /___/_/ |_/ /_/ /_____/
                               
    """
    print(banner)
    print("Developed by @Nox8 - Version 2.3.0-beta")

def display_progress_bar():
    for _ in tqdm(range(100), desc="Initializing XRET", ncols=100):
        time.sleep(0.02)

def main():
    display_banner()
    display_progress_bar()

    parser = argparse.ArgumentParser(description="XRET: Advanced Web and Network Vulnerability Scanner")
    parser.add_argument('target', type=str, nargs='?', help='Target URL or IP to scan')
    parser.add_argument('--dynamic', action='store_true', help='Enable dynamic scanning using Pyppeteer')
    parser.add_argument('--max-threads', type=int, default=4, help='Maximum number of parallel threads')
    parser.add_argument('--show', action='store_true', help='Display tool information without scanning')

    args = parser.parse_args()

    if args.show:
        parser.print_help()
    elif args.target:
        xret = XRET(args.target, dynamic=args.dynamic, max_threads=args.max_threads)
        if args.dynamic:
            loop = asyncio.get_event_loop()
            loop.run_until_complete(xret.scan_vulnerabilities())
        else:
            xret.scan_vulnerabilities()

        xret.generate_report()
        xret.integrate_with_security_systems()
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
